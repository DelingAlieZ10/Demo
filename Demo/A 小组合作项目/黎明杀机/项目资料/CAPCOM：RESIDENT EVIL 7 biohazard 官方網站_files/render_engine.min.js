var RenderEngine=function(){this._camera=this._renderElement=this._renderer=this._container=null;this._postprocess={enabled:!1};this._rootScene=null;this._parameters={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat};this._ssaoParameters={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat};this._composer=null;this._shaders=[];this._cameraZoomLevel=65;this._cameraNear=1;this._cameraFar=1E4;this._cameraPosition=new THREE.Vector3(0,-3,5);
this._cameraLookAt=new THREE.Vector3(0,-3,0);this._isRunning=!1;this._activeScene=null;this._depthMaterial=new THREE.MeshBasicMaterial;this._ssaoDepathMaterial=new THREE.MeshDepthMaterial;this._ssaoDepathMaterial.depthPacking=THREE.RGBADepthPacking;this._ssaoDepathMaterial.blending=THREE.NoBlending;this._ssaoDepthTarget=this._depthTarget=this._depthTexture=null};RenderEngine.Shader={};RenderEngine.Shader.Dof=new WAGNER.GuidedFullBoxBlurPass;RenderEngine.Shader.Cga=new WAGNER.CGAPass;
RenderEngine.Shader.Noise=new WAGNER.NoisePass;RenderEngine.Shader.Noise.params.speed=.2;RenderEngine.Shader.Noise.params.amount=.3;RenderEngine.Shader.ChromaticAberration=new WAGNER.ChromaticAberrationPass;RenderEngine.Shader.Halftone=new WAGNER.HalftonePass;RenderEngine.Shader.Halftone2=new WAGNER.Halftone2Pass;RenderEngine.Shader.MultiPassBloom=new WAGNER.MultiPassBloomPass;RenderEngine.Shader.MultiPassBloom.params.blurAmount=2;RenderEngine.Shader.Vignette=new WAGNER.VignettePass;
RenderEngine.Shader.BoxBlur=new WAGNER.BoxBlurPass;RenderEngine.ShaderEnable={};RenderEngine.ShaderEnable.RadialBlur=!1;RenderEngine.ShaderEnable.Dof=!1;RenderEngine.ShaderEnable.Cga=!1;RenderEngine.ShaderEnable.Noise=!1;RenderEngine.ShaderEnable.ChromaticAberration=!1;RenderEngine.ShaderEnable.Halftone=!1;RenderEngine.ShaderEnable.Halftone2=!1;RenderEngine.ShaderEnable.MultiPassBloom=!1;RenderEngine.ShaderEnable.Ssao=!1;RenderEngine.ShaderEnable.Raster=!1;RenderEngine.ShaderEnable.Vignette=!1;
RenderEngine.ShaderEnable.BoxBlur=!1;RenderEngine.ShaderMaterial={};RenderEngine.ShaderMaterial.Raster=new THREE.ShaderMaterial({uniforms:{resolution:{type:"v2",value:new THREE.Vector2(1,1)},time:{type:"f",value:Date.now()},tInput:{type:"t",value:null},wave_phase:{type:"f",value:1},wave_size:{type:"f",value:30}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tInput;\nuniform float wave_phase;\nuniform float wave_size;\nvarying vec2 vUv;\nvoid main()\n{\nvec2 p = vUv;\np.x = mod(1.0 + p.x + 0.05*sin(p.y * wave_size + wave_phase * 0.75), 1.0);\ngl_FragColor = texture2D(tInput, p);\n}"});
RenderEngine.ShaderMaterial.RadialBlur=new THREE.ShaderMaterial({uniforms:{resolution:{type:"v2",value:new THREE.Vector2(1,1)},time:{type:"f",value:Date.now()},tInput:{type:"t",value:null},tDepth:{type:"t",value:null},steps:{type:"f",value:80},strength:{type:"f",value:.98},expo:{type:"f",value:3},center:{type:"v2",value:new THREE.Vector2(.5,.5)}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float steps;\nuniform float strength;\nuniform float expo;\nuniform sampler2D tInput;\nuniform sampler2D tDepth;\nuniform vec2 center;\nvarying vec2 vUv;\nvoid main() {\nvec2 s = vUv;\nvec3 total = vec3(0.0);\nvec2 d = (center-vUv)/steps;\nfloat w = 1.0;\nfor( int i=0; i<80; i++ ) {\nvec3 res = texture2D( tDepth, s).xyz;\nres = smoothstep(0.0,1.0,res);\ntotal += w*res;\nw *= strength;\ns += d;\n}\ntotal /= steps;\nvec3 dif = texture2D( tInput, vUv).xyz;\ngl_FragColor = vec4( mix(total*expo, dif*2.0, 0.5), 1.0);\n}"});
RenderEngine.ShaderMaterial.Dot=new THREE.ShaderMaterial({uniforms:{resolution:{type:"v2",value:new THREE.Vector2(1,1)},time:{type:"f",value:Date.now()},tInput:{type:"t",value:null},tSize:{type:"v2",value:new THREE.Vector2(256,256)},center:{type:"v2",value:new THREE.Vector2(.5,.5)},angle:{type:"f",value:1.57},scale:{type:"f",value:1}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform vec2 center;\nuniform float angle;\nuniform float scale;\nuniform vec2 tSize;\nuniform sampler2D tInput;\nvarying vec2 vUv;\nfloat pattern() {\nfloat s = sin( angle ), c = cos( angle );\nvec2 tex = vUv * tSize - center;\nvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\nreturn ( sin( point.x ) * sin( point.y ) ) * 4.0;\n}\nvoid main() {\nvec4 color = texture2D( tInput, vUv );\nfloat average = ( color.r + color.g + color.b ) / 3.0;\ngl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\n}"});
RenderEngine.ShaderMaterial.Ssao=new THREE.ShaderMaterial({uniforms:{resolution:{type:"v2",value:new THREE.Vector2(1,1)},time:{type:"f",value:Date.now()},tInput:{type:"t",value:null},tDepth:{value:null},size:{value:new THREE.Vector2(512,512)},cameraNear:{value:1},cameraFar:{value:100},onlyAO:{value:0},aoClamp:{value:.5},lumInfluence:{value:.5}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float cameraNear;\nuniform float cameraFar;\nuniform bool onlyAO;\nuniform vec2 size;\nuniform float aoClamp;\nuniform float lumInfluence;\nuniform sampler2D tInput;\nuniform sampler2D tDepth;\nvarying vec2 vUv;\n#define DL 2.399963229728653\n#define EULER 2.718281828459045\nconst int samples = 8;\nconst float radius = 5.0;\nconst bool useNoise = false;\nconst float noiseAmount = 0.0003;\nconst float diffArea = 0.4;\nconst float gDisplace = 0.4;\n#include <packing>\nvec2 rand( const vec2 coord ) {\nvec2 noise;\nif ( useNoise ) {\nfloat nx = dot ( coord, vec2( 12.9898, 78.233 ) );\nfloat ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\nnoise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\n} else {\nfloat ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) );\nfloat gg = fract( coord.t * ( size.y / 2.0 ) );\nnoise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\n}\nreturn ( noise * 2.0  - 1.0 ) * noiseAmount;\n}\nfloat readDepth( const in vec2 coord ) {\nfloat cameraFarPlusNear = cameraFar + cameraNear;\nfloat cameraFarMinusNear = cameraFar - cameraNear;\nfloat cameraCoef = 2.0 * cameraNear;\nreturn cameraCoef / ( cameraFarPlusNear - unpackRGBAToDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );\n}\nfloat compareDepths( const in float depth1, const in float depth2, inout int far ) {\nfloat garea = 2.0;\nfloat diff = ( depth1 - depth2 ) * 100.0;\nif ( diff < gDisplace ) {\ngarea = diffArea;\n} else {\nfar = 1;\n}\nfloat dd = diff - gDisplace;\nfloat gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );\nreturn gauss;\n}\nfloat calcAO( float depth, float dw, float dh ) {\nfloat dd = radius - depth * radius;\nvec2 vv = vec2( dw, dh );\nvec2 coord1 = vUv + dd * vv;\nvec2 coord2 = vUv - dd * vv;\nfloat temp1 = 0.0;\nfloat temp2 = 0.0;\nint far = 0;\ntemp1 = compareDepths( depth, readDepth( coord1 ), far );\nif ( far > 0 ) {\ntemp2 = compareDepths( readDepth( coord2 ), depth, far );\ntemp1 += ( 1.0 - temp1 ) * temp2;\n}\nreturn temp1;\n}\nvoid main() {\nvec2 noise = rand( vUv );\nfloat depth = readDepth( vUv );\nfloat tt = clamp( depth, aoClamp, 1.0 );\nfloat w = ( 1.0 / size.x )  / tt + ( noise.x * ( 1.0 - noise.x ) );\nfloat h = ( 1.0 / size.y ) / tt + ( noise.y * ( 1.0 - noise.y ) );\nfloat ao = 0.0;\nfloat dz = 1.0 / float( samples );\nfloat z = 1.0 - dz / 2.0;\nfloat l = 0.0;\nfor ( int i = 0; i <= samples; i ++ ) {\nfloat r = sqrt( 1.0 - z );\nfloat pw = cos( l ) * r;\nfloat ph = sin( l ) * r;\nao += calcAO( depth, pw * w, ph * h );\nz = z - dz;\nl = l + DL;\n}\nao /= float( samples );\nao = 1.0 - ao;\nvec3 color = texture2D( tInput, vUv ).rgb;\nvec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );\nfloat lum = dot( color.rgb, lumcoeff );\nvec3 luminance = vec3( lum );\nvec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\nif ( onlyAO ) {\nfinal = vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\n}\ngl_FragColor = vec4( final, 1.0 );\n}"});
RenderEngine.Detector={webgl:function(){try{var a=document.createElement("canvas"),b=a.getContext("webgl")||a.getContext("experimental-webgl");return!!(window.WebGLRenderingContext&&b&&b.getShaderPrecisionFormat)}catch(c){return!1}}()};
RenderEngine.prototype.initialize=function(a){this._container=document.createElement("div");$(a).append(this._container);this._camera=new THREE.PerspectiveCamera(this._cameraZoomLevel,$(a).width()/$(a).height(),this._cameraNear,this._cameraFar);this._camera.position.set(this._cameraPosition.x,this._cameraPosition.y,this._cameraPosition.z);this._camera.lookAt(this._cameraLookAt);this._rootScene=new THREE.Scene;this._renderer=new THREE.WebGLRenderer({antialias:!1});this._renderer.setPixelRatio(window.devicePixelRatio);
this._renderer.setSize($(a).width(),$(a).height());this._renderer.autoClear=!1;this._renderer.autoUpdateObjects=!1;this._container.appendChild(this._renderer.domElement);this._composer=new WAGNER.Composer(this._renderer,{useRGBA:!1});this._composer.setSize(1.5*$(a).width(),1.5*$(a).height());this.setupShaders()};
RenderEngine.prototype.setupShaders=function(){var a=this,b=new ShaderLoader;b.add("depth-vs",WAGNER.vertexShadersPath+"/packed-depth-vs.glsl");b.add("depth-fs",WAGNER.fragmentShadersPath+"/packed-depth-fs.glsl");b.load();b.onLoaded(function(){a._depthMaterial=new THREE.ShaderMaterial({uniforms:{mNear:{type:"f",value:a._camera.near},mFar:{type:"f",value:a._camera.far}},vertexShader:this.get("depth-vs"),fragmentShader:this.get("depth-fs"),shading:THREE.SmoothShading})});this._depthTexture=WAGNER.Pass.prototype.getOfflineTexture(this._composer.width,
this._composer.height,!1);this._depthTarget=new THREE.WebGLRenderTarget(1*this._composer.width,1*this._composer.height,this._parameters);RenderEngine.ShaderMaterial.RadialBlur.uniforms.tDepth.value=this._depthTarget;this._ssaoDepthTarget=new THREE.WebGLRenderTarget(1*this._composer.width,1*this._composer.height,this._ssaoParameters);RenderEngine.ShaderMaterial.Ssao.uniforms.tDepth.value=this._ssaoDepthTarget.texture;RenderEngine.ShaderMaterial.Ssao.uniforms.size.value.set(this._composer.width,this._composer.height);
RenderEngine.ShaderMaterial.Ssao.uniforms.cameraNear.value=this._camera.near;RenderEngine.ShaderMaterial.Ssao.uniforms.cameraFar.value=this._camera.far;RenderEngine.ShaderMaterial.Ssao.uniforms.onlyAO.value=0;RenderEngine.ShaderMaterial.Ssao.uniforms.aoClamp.value=.6;RenderEngine.ShaderMaterial.Ssao.uniforms.lumInfluence.value=.2};RenderEngine.prototype.addRootScene=function(a){this._rootScene.add(a)};RenderEngine.prototype.startRender=function(){if(this._isRunning)return!1;this._isRunning=!0;this.animate()};
RenderEngine.prototype.stopRender=function(){this._isRunning=!1};RenderEngine.prototype.animate=function(a){this._isRunning&&requestAnimationFrame(this.animate.bind(this));this._activeScene&&this._activeScene.update(a);this._activeScene&&this._activeScene.preRender();this.render();this._activeScene&&this._activeScene.postRender()};
RenderEngine.prototype.render=function(){this._composer.reset();RenderEngine.ShaderEnable.Dof&&(this._depthMaterial.side=THREE.DoubleSide,this._rootScene.overrideMaterial=this._depthMaterial,this._composer.render(this._rootScene,this._camera,null,this._depthTexture),RenderEngine.Shader.Dof.params.tBias=this._depthTexture);RenderEngine.ShaderEnable.Ssao&&(this._rootScene.overrideMaterial=this._ssaoDepathMaterial,this._renderer.render(this._rootScene,this._camera,this._ssaoDepthTarget,!0));this._rootScene.overrideMaterial=
null;this._composer.render(this._rootScene,this._camera);RenderEngine.ShaderEnable.Noise&&this._composer.pass(RenderEngine.Shader.Noise);RenderEngine.ShaderEnable.Cga&&this._composer.pass(RenderEngine.Shader.Cga);RenderEngine.ShaderEnable.ChromaticAberration&&this._composer.pass(RenderEngine.Shader.ChromaticAberration);RenderEngine.ShaderEnable.Halftone2&&this._composer.pass(RenderEngine.Shader.Halftone2);RenderEngine.ShaderEnable.Halftone&&this._composer.pass(RenderEngine.Shader.Halftone);RenderEngine.ShaderEnable.MultiPassBloom&&
this._composer.pass(RenderEngine.Shader.MultiPassBloom);RenderEngine.ShaderEnable.RadialBlur&&this._composer.pass(RenderEngine.ShaderMaterial.RadialBlur);RenderEngine.ShaderEnable.Ssao&&this._composer.pass(RenderEngine.ShaderMaterial.Ssao);RenderEngine.ShaderEnable.Raster&&this._composer.pass(RenderEngine.ShaderMaterial.Raster);RenderEngine.ShaderEnable.Dof&&this._composer.pass(RenderEngine.Shader.Dof);RenderEngine.ShaderEnable.Vignette&&this._composer.pass(RenderEngine.Shader.Vignette);RenderEngine.ShaderEnable.BoxBlur&&
this._composer.pass(RenderEngine.Shader.BoxBlur);this._composer.toScreen()};RenderEngine.prototype.enableShader=function(a){};RenderEngine.prototype.setActiveScene=function(a){this._activeScene=a};
